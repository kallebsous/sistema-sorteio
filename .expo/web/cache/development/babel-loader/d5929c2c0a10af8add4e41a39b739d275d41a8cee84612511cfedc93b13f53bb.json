{"ast":null,"code":"\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { createContext, useContext, useState, useEffect } from \"react\";\nimport AsyncStorage from \"@react-native-async-storage/async-storage\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar ContextoEscalonador = createContext(undefined);\nvar CORES_PROCESSOS = [\"#F44336\", \"#2196F3\", \"#4CAF50\", \"#FF9800\", \"#9C27B0\", \"#00BCD4\", \"#FFEB3B\", \"#795548\", \"#607D8B\", \"#E91E63\", \"#3F51B5\", \"#009688\", \"#FFC107\", \"#8BC34A\", \"#673AB7\"];\nvar gerarIdUnico = function gerarIdUnico() {\n  return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);\n};\nexport var ProvedorEscalonador = function ProvedorEscalonador(_ref) {\n  var children = _ref.children;\n  var _useState = useState([]),\n    _useState2 = _slicedToArray(_useState, 2),\n    processos = _useState2[0],\n    setProcessos = _useState2[1];\n  var _useState3 = useState(2),\n    _useState4 = _slicedToArray(_useState3, 2),\n    quantumTempo = _useState4[0],\n    setQuantumTempo = _useState4[1];\n  var _useState5 = useState(0),\n    _useState6 = _slicedToArray(_useState5, 2),\n    sobrecargaTrocaContexto = _useState6[0],\n    setSobrecargaTrocaContexto = _useState6[1];\n  var _useState7 = useState(1),\n    _useState8 = _slicedToArray(_useState7, 2),\n    velocidadeSimulacao = _useState8[0],\n    setVelocidadeSimulacao = _useState8[1];\n  var _useState9 = useState(null),\n    _useState0 = _slicedToArray(_useState9, 2),\n    resultadoSimulacao = _useState0[0],\n    setResultadoSimulacao = _useState0[1];\n  var _useState1 = useState(false),\n    _useState10 = _slicedToArray(_useState1, 2),\n    simulacaoEmExecucao = _useState10[0],\n    setSimulacaoEmExecucao = _useState10[1];\n  var _useState11 = useState(2),\n    _useState12 = _slicedToArray(_useState11, 2),\n    tempoIO = _useState12[0],\n    setTempoIO = _useState12[1];\n  useEffect(function () {\n    var carregarConfiguracoes = function () {\n      var _ref2 = _asyncToGenerator(function* () {\n        try {\n          var dados = yield AsyncStorage.multiGet([\"processos\", \"quantumTempo\", \"sobrecargaTrocaContexto\", \"velocidadeSimulacao\", \"tempoIO\"]);\n          setProcessos(dados[0][1] ? JSON.parse(dados[0][1]) : []);\n          setQuantumTempo(dados[1][1] ? Number(dados[1][1]) : 2);\n          setSobrecargaTrocaContexto(dados[2][1] ? Number(dados[2][1]) : 0);\n          setVelocidadeSimulacao(dados[3][1] ? Number(dados[3][1]) : 1);\n          setTempoIO(dados[4][1] ? Number(dados[4][1]) : 2);\n        } catch (erro) {\n          console.error(\"Erro ao carregar configurações:\", erro);\n        }\n      });\n      return function carregarConfiguracoes() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    carregarConfiguracoes();\n  }, []);\n  useEffect(function () {\n    AsyncStorage.multiSet([[\"processos\", JSON.stringify(processos)], [\"quantumTempo\", quantumTempo.toString()], [\"sobrecargaTrocaContexto\", sobrecargaTrocaContexto.toString()], [\"velocidadeSimulacao\", velocidadeSimulacao.toString()], [\"tempoIO\", tempoIO.toString()]]);\n  }, [processos, quantumTempo, sobrecargaTrocaContexto, velocidadeSimulacao, tempoIO]);\n  var adicionarProcesso = function adicionarProcesso(processo) {\n    var novoProcesso = _objectSpread(_objectSpread({}, processo), {}, {\n      id: gerarIdUnico(),\n      estado: \"pronto\",\n      tempoEspera: 0,\n      tempoRetorno: 0,\n      tempoResposta: null,\n      tempoFinalizacao: null,\n      tempoRestanteCPU: 0,\n      tempoRestanteIO: 0,\n      ioBursts: [],\n      cpuBursts: [],\n      burstAtual: 0,\n      cor: CORES_PROCESSOS[processos.length % CORES_PROCESSOS.length]\n    });\n    if (processo.tipo === \"io\") {\n      var tempoRestante = processo.tempoExecucaoTotal;\n      while (tempoRestante > 0) {\n        var cpuBurst = Math.min(Math.ceil(Math.random() * 4), tempoRestante);\n        novoProcesso.cpuBursts.push(cpuBurst);\n        novoProcesso.ioBursts.push(tempoIO);\n        tempoRestante -= cpuBurst;\n      }\n      novoProcesso.tempoRestanteCPU = novoProcesso.cpuBursts[0];\n    } else {\n      novoProcesso.cpuBursts = [processo.tempoExecucaoTotal];\n      novoProcesso.tempoRestanteCPU = processo.tempoExecucaoTotal;\n    }\n    setProcessos(function (prev) {\n      return [].concat(_toConsumableArray(prev), [novoProcesso]);\n    });\n  };\n  var atualizarProcesso = function atualizarProcesso(processoAtualizado) {\n    setProcessos(function (prev) {\n      return prev.map(function (p) {\n        return p.id === processoAtualizado.id ? processoAtualizado : p;\n      });\n    });\n  };\n  var excluirProcesso = function excluirProcesso(id) {\n    setProcessos(function (prev) {\n      return prev.filter(function (p) {\n        return p.id !== id;\n      });\n    });\n  };\n  var limparProcessos = function limparProcessos() {\n    setProcessos([]);\n    setResultadoSimulacao(null);\n  };\n  var gerarProcessosAleatorios = function gerarProcessosAleatorios(quantidade) {\n    var novosProcessos = Array.from({\n      length: quantidade\n    }, function (_, i) {\n      var tipo = Math.random() > 0.5 ? \"cpu\" : \"io\";\n      return {\n        id: gerarIdUnico(),\n        nome: `${tipo.toUpperCase()}-P${i + 1}`,\n        tipo: tipo,\n        tempoChegada: Math.floor(Math.random() * 10),\n        tempoExecucaoTotal: Math.floor(Math.random() * 15) + 5,\n        bilhetes: Math.floor(Math.random() * 10) + 1,\n        cor: CORES_PROCESSOS[i % CORES_PROCESSOS.length],\n        estado: \"pronto\",\n        tempoEspera: 0,\n        tempoRetorno: 0,\n        tempoResposta: null,\n        tempoFinalizacao: null,\n        tempoRestanteCPU: 0,\n        tempoRestanteIO: 0,\n        ioBursts: [],\n        cpuBursts: [],\n        burstAtual: 0\n      };\n    }).map(function (p) {\n      if (p.tipo === \"io\") {\n        var tempoRestante = p.tempoExecucaoTotal;\n        while (tempoRestante > 0) {\n          var cpuBurst = Math.min(Math.ceil(Math.random() * 4), tempoRestante);\n          p.cpuBursts.push(cpuBurst);\n          p.ioBursts.push(tempoIO);\n          tempoRestante -= cpuBurst;\n        }\n        p.tempoRestanteCPU = p.cpuBursts[0];\n      } else {\n        p.cpuBursts = [p.tempoExecucaoTotal];\n        p.tempoRestanteCPU = p.tempoExecucaoTotal;\n      }\n      return p;\n    });\n    setProcessos(novosProcessos);\n  };\n  var executarSimulacao = function executarSimulacao() {\n    setSimulacaoEmExecucao(true);\n    var processosClone = JSON.parse(JSON.stringify(processos));\n    var linhaDoTempo = [];\n    var tempoAtual = 0;\n    var processoAtual = null;\n    var tempoExecutando = 0;\n    var processosFinalizados = 0;\n    while (processosFinalizados < processosClone.length) {\n      processosClone.forEach(function (p) {\n        if (p.estado === \"esperando\") {\n          p.tempoRestanteIO--;\n          if (p.tempoRestanteIO <= 0) {\n            p.estado = \"pronto\";\n            p.burstAtual++;\n            if (p.burstAtual < p.cpuBursts.length) {\n              p.tempoRestanteCPU = p.cpuBursts[p.burstAtual];\n            }\n          }\n        }\n      });\n      var processosProntos = processosClone.filter(function (p) {\n        return p.estado === \"pronto\" && p.tempoChegada <= tempoAtual && p.tempoRestanteCPU > 0;\n      });\n      if (!processoAtual || tempoExecutando >= quantumTempo) {\n        if (processosProntos.length > 0) {\n          var totalBilhetes = processosProntos.reduce(function (sum, p) {\n            return sum + p.bilhetes;\n          }, 0);\n          var bilheteVencedor = Math.floor(Math.random() * totalBilhetes) + 1;\n          var acumulador = 0;\n          for (var p of processosProntos) {\n            acumulador += p.bilhetes;\n            if (acumulador >= bilheteVencedor) {\n              processoAtual = p;\n              break;\n            }\n          }\n          if (sobrecargaTrocaContexto > 0 && linhaDoTempo.length > 0) {\n            for (var i = 0; i < sobrecargaTrocaContexto; i++) {\n              linhaDoTempo.push({\n                tempo: tempoAtual + i,\n                processoId: null,\n                tipo: \"ocioso\"\n              });\n            }\n            tempoAtual += sobrecargaTrocaContexto;\n          }\n          tempoExecutando = 0;\n          if (processoAtual.tempoResposta === null) {\n            processoAtual.tempoResposta = tempoAtual - processoAtual.tempoChegada;\n          }\n        }\n      }\n      if (processoAtual) {\n        linhaDoTempo.push({\n          tempo: tempoAtual,\n          processoId: processoAtual.id,\n          tipo: processoAtual.tipo === \"cpu\" ? \"cpu\" : \"io\"\n        });\n        processoAtual.tempoRestanteCPU--;\n        tempoExecutando++;\n        if (processoAtual.tempoRestanteCPU <= 0) {\n          if (processoAtual.tipo === \"io\" && processoAtual.burstAtual < processoAtual.ioBursts.length) {\n            processoAtual.tempoRestanteIO = processoAtual.ioBursts[processoAtual.burstAtual];\n            processoAtual.estado = \"esperando\";\n          } else {\n            processoAtual.estado = \"finalizado\";\n            processoAtual.tempoFinalizacao = tempoAtual + 1;\n            processoAtual.tempoRetorno = processoAtual.tempoFinalizacao - processoAtual.tempoChegada;\n            processosFinalizados++;\n          }\n          processoAtual = null;\n        }\n      } else {\n        linhaDoTempo.push({\n          tempo: tempoAtual,\n          processoId: null,\n          tipo: \"ocioso\"\n        });\n      }\n      processosProntos.forEach(function (p) {\n        if (p !== processoAtual) p.tempoEspera++;\n      });\n      tempoAtual++;\n    }\n    var tempoEsperaTotal = 0;\n    var tempoRetornoTotal = 0;\n    var tempoRespostaTotal = 0;\n    var tempoCPUUtilizado = 0;\n    var tempoIOUtilizado = 0;\n    processosClone.forEach(function (p) {\n      tempoEsperaTotal += p.tempoEspera;\n      tempoRetornoTotal += p.tempoRetorno;\n      tempoRespostaTotal += p.tempoResposta || 0;\n      if (p.tipo === \"cpu\") {\n        tempoCPUUtilizado += p.tempoExecucaoTotal;\n      } else {\n        tempoCPUUtilizado += p.cpuBursts.reduce(function (a, b) {\n          return a + b;\n        }, 0);\n        tempoIOUtilizado += p.ioBursts.reduce(function (a, b) {\n          return a + b;\n        }, 0);\n      }\n    });\n    var tempoTotal = linhaDoTempo.length;\n    var tempoOcioso = linhaDoTempo.filter(function (f) {\n      return f.tipo === \"ocioso\";\n    }).length;\n    var resultado = {\n      linhaDoTempo: linhaDoTempo,\n      processos: processosClone,\n      tempoEsperaMedia: tempoEsperaTotal / processosClone.length,\n      tempoRetornoMedio: tempoRetornoTotal / processosClone.length,\n      tempoRespostaMedio: tempoRespostaTotal / processosClone.length,\n      utilizacaoCPU: (tempoCPUUtilizado - tempoOcioso) / tempoTotal * 100,\n      utilizacaoIO: tempoIOUtilizado / tempoTotal * 100,\n      vazao: processosClone.length / tempoTotal\n    };\n    setResultadoSimulacao(resultado);\n    setSimulacaoEmExecucao(false);\n    return resultado;\n  };\n  return _jsx(ContextoEscalonador.Provider, {\n    value: {\n      processos: processos,\n      adicionarProcesso: adicionarProcesso,\n      atualizarProcesso: atualizarProcesso,\n      excluirProcesso: excluirProcesso,\n      limparProcessos: limparProcessos,\n      quantumTempo: quantumTempo,\n      setQuantumTempo: setQuantumTempo,\n      sobrecargaTrocaContexto: sobrecargaTrocaContexto,\n      setSobrecargaTrocaContexto: setSobrecargaTrocaContexto,\n      velocidadeSimulacao: velocidadeSimulacao,\n      setVelocidadeSimulacao: setVelocidadeSimulacao,\n      resultadoSimulacao: resultadoSimulacao,\n      setResultadoSimulacao: setResultadoSimulacao,\n      executarSimulacao: executarSimulacao,\n      gerarProcessosAleatorios: gerarProcessosAleatorios,\n      simulacaoEmExecucao: simulacaoEmExecucao,\n      setSimulacaoEmExecucao: setSimulacaoEmExecucao,\n      tempoIO: tempoIO,\n      setTempoIO: setTempoIO\n    },\n    children: children\n  });\n};\nexport var useEscalonador = function useEscalonador() {\n  var context = useContext(ContextoEscalonador);\n  if (!context) throw new Error(\"useEscalonador deve ser usado dentro de ProvedorEscalonador\");\n  return context;\n};","map":{"version":3,"names":["_toConsumableArray","_defineProperty","_asyncToGenerator","_slicedToArray","ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","defineProperty","createContext","useContext","useState","useEffect","AsyncStorage","jsx","_jsx","ContextoEscalonador","undefined","CORES_PROCESSOS","gerarIdUnico","Date","now","toString","Math","random","substr","ProvedorEscalonador","_ref","children","_useState","_useState2","processos","setProcessos","_useState3","_useState4","quantumTempo","setQuantumTempo","_useState5","_useState6","sobrecargaTrocaContexto","setSobrecargaTrocaContexto","_useState7","_useState8","velocidadeSimulacao","setVelocidadeSimulacao","_useState9","_useState0","resultadoSimulacao","setResultadoSimulacao","_useState1","_useState10","simulacaoEmExecucao","setSimulacaoEmExecucao","_useState11","_useState12","tempoIO","setTempoIO","carregarConfiguracoes","_ref2","dados","multiGet","JSON","parse","Number","erro","console","error","multiSet","stringify","adicionarProcesso","processo","novoProcesso","id","estado","tempoEspera","tempoRetorno","tempoResposta","tempoFinalizacao","tempoRestanteCPU","tempoRestanteIO","ioBursts","cpuBursts","burstAtual","cor","tipo","tempoRestante","tempoExecucaoTotal","cpuBurst","min","ceil","prev","concat","atualizarProcesso","processoAtualizado","map","p","excluirProcesso","limparProcessos","gerarProcessosAleatorios","quantidade","novosProcessos","Array","from","_","i","nome","toUpperCase","tempoChegada","floor","bilhetes","executarSimulacao","processosClone","linhaDoTempo","tempoAtual","processoAtual","tempoExecutando","processosFinalizados","processosProntos","totalBilhetes","reduce","sum","bilheteVencedor","acumulador","tempo","processoId","tempoEsperaTotal","tempoRetornoTotal","tempoRespostaTotal","tempoCPUUtilizado","tempoIOUtilizado","a","b","tempoTotal","tempoOcioso","f","resultado","tempoEsperaMedia","tempoRetornoMedio","tempoRespostaMedio","utilizacaoCPU","utilizacaoIO","vazao","Provider","value","useEscalonador","context","Error"],"sources":["C:/Users/kalle/Downloads/sistema-sorteio/contexto/ContextoEscalonador.tsx"],"sourcesContent":["\"use client\"\n\nimport type React from \"react\"\nimport { createContext, useContext, useState, useEffect } from \"react\"\nimport AsyncStorage from \"@react-native-async-storage/async-storage\"\n\nexport type TipoProcesso = \"cpu\" | \"io\"\n\nexport type Processo = {\n  id: string\n  nome: string\n  tipo: TipoProcesso\n  tempoChegada: number\n  tempoExecucaoTotal: number\n  tempoRestanteCPU: number\n  tempoRestanteIO: number\n  bilhetes: number\n  cor: string\n  estado: \"pronto\" | \"executando\" | \"esperando\" | \"finalizado\"\n  tempoEspera: number\n  tempoRetorno: number\n  tempoResposta: number | null\n  tempoFinalizacao: number | null\n  ioBursts: number[]\n  cpuBursts: number[]\n  burstAtual: number\n}\n\nexport type FatiaTempoExecucao = {\n  tempo: number\n  processoId: string | null\n  tipo: \"cpu\" | \"io\" | \"ocioso\"\n}\n\nexport type ResultadoSimulacao = {\n  linhaDoTempo: FatiaTempoExecucao[]\n  processos: Processo[]\n  tempoEsperaMedia: number\n  tempoRetornoMedio: number\n  tempoRespostaMedio: number\n  utilizacaoCPU: number\n  utilizacaoIO: number\n  vazao: number\n}\n\ntype ContextoEscalonadorType = {\n  processos: Processo[]\n  adicionarProcesso: (processo: Omit<Processo, \n    \"id\" | \"estado\" | \"tempoEspera\" | \"tempoRetorno\" | \"tempoResposta\" | \n    \"tempoFinalizacao\" | \"tempoRestanteCPU\" | \"tempoRestanteIO\" | \n    \"ioBursts\" | \"cpuBursts\" | \"burstAtual\" | \"cor\"\n  >) => void\n  atualizarProcesso: (processo: Processo) => void\n  excluirProcesso: (id: string) => void\n  limparProcessos: () => void\n  quantumTempo: number\n  setQuantumTempo: (valor: number) => void\n  sobrecargaTrocaContexto: number\n  setSobrecargaTrocaContexto: (valor: number) => void\n  velocidadeSimulacao: number\n  setVelocidadeSimulacao: (valor: number) => void\n  resultadoSimulacao: ResultadoSimulacao | null\n  setResultadoSimulacao: (resultado: ResultadoSimulacao | null) => void\n  executarSimulacao: () => ResultadoSimulacao\n  gerarProcessosAleatorios: (quantidade: number) => void\n  simulacaoEmExecucao: boolean\n  setSimulacaoEmExecucao: (valor: boolean) => void\n  tempoIO: number\n  setTempoIO: (valor: number) => void\n}\n\nconst ContextoEscalonador = createContext<ContextoEscalonadorType | undefined>(undefined)\n\nconst CORES_PROCESSOS = [\n  \"#F44336\", \"#2196F3\", \"#4CAF50\", \"#FF9800\", \"#9C27B0\",\n  \"#00BCD4\", \"#FFEB3B\", \"#795548\", \"#607D8B\", \"#E91E63\",\n  \"#3F51B5\", \"#009688\", \"#FFC107\", \"#8BC34A\", \"#673AB7\"\n]\n\nconst gerarIdUnico = () => Date.now().toString(36) + Math.random().toString(36).substr(2, 9)\n\nexport const ProvedorEscalonador: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const [processos, setProcessos] = useState<Processo[]>([])\n  const [quantumTempo, setQuantumTempo] = useState(2)\n  const [sobrecargaTrocaContexto, setSobrecargaTrocaContexto] = useState(0)\n  const [velocidadeSimulacao, setVelocidadeSimulacao] = useState(1)\n  const [resultadoSimulacao, setResultadoSimulacao] = useState<ResultadoSimulacao | null>(null)\n  const [simulacaoEmExecucao, setSimulacaoEmExecucao] = useState(false)\n  const [tempoIO, setTempoIO] = useState(2)\n\n  useEffect(() => {\n    const carregarConfiguracoes = async () => {\n      try {\n        const dados = await AsyncStorage.multiGet([\n          \"processos\", \"quantumTempo\", \"sobrecargaTrocaContexto\", \n          \"velocidadeSimulacao\", \"tempoIO\"\n        ])\n        \n        setProcessos(dados[0][1] ? JSON.parse(dados[0][1]) : [])\n        setQuantumTempo(dados[1][1] ? Number(dados[1][1]) : 2)\n        setSobrecargaTrocaContexto(dados[2][1] ? Number(dados[2][1]) : 0)\n        setVelocidadeSimulacao(dados[3][1] ? Number(dados[3][1]) : 1)\n        setTempoIO(dados[4][1] ? Number(dados[4][1]) : 2)\n      } catch (erro) {\n        console.error(\"Erro ao carregar configurações:\", erro)\n      }\n    }\n    carregarConfiguracoes()\n  }, [])\n\n  useEffect(() => {\n    AsyncStorage.multiSet([\n      [\"processos\", JSON.stringify(processos)],\n      [\"quantumTempo\", quantumTempo.toString()],\n      [\"sobrecargaTrocaContexto\", sobrecargaTrocaContexto.toString()],\n      [\"velocidadeSimulacao\", velocidadeSimulacao.toString()],\n      [\"tempoIO\", tempoIO.toString()]\n    ])\n  }, [processos, quantumTempo, sobrecargaTrocaContexto, velocidadeSimulacao, tempoIO])\n\n  const adicionarProcesso = (processo: Omit<Processo, \n    \"id\" | \"estado\" | \"tempoEspera\" | \"tempoRetorno\" | \"tempoResposta\" | \n    \"tempoFinalizacao\" | \"tempoRestanteCPU\" | \"tempoRestanteIO\" | \n    \"ioBursts\" | \"cpuBursts\" | \"burstAtual\" | \"cor\"\n  >) => {\n    const novoProcesso: Processo = {\n      ...processo,\n      id: gerarIdUnico(),\n      estado: \"pronto\",\n      tempoEspera: 0,\n      tempoRetorno: 0,\n      tempoResposta: null,\n      tempoFinalizacao: null,\n      tempoRestanteCPU: 0,\n      tempoRestanteIO: 0,\n      ioBursts: [],\n      cpuBursts: [],\n      burstAtual: 0,\n      cor: CORES_PROCESSOS[processos.length % CORES_PROCESSOS.length]\n    }\n\n    if (processo.tipo === \"io\") {\n      let tempoRestante = processo.tempoExecucaoTotal\n      while (tempoRestante > 0) {\n        const cpuBurst = Math.min(Math.ceil(Math.random() * 4), tempoRestante)\n        novoProcesso.cpuBursts.push(cpuBurst)\n        novoProcesso.ioBursts.push(tempoIO)\n        tempoRestante -= cpuBurst\n      }\n      novoProcesso.tempoRestanteCPU = novoProcesso.cpuBursts[0]\n    } else {\n      novoProcesso.cpuBursts = [processo.tempoExecucaoTotal]\n      novoProcesso.tempoRestanteCPU = processo.tempoExecucaoTotal\n    }\n\n    setProcessos(prev => [...prev, novoProcesso])\n  }\n\n  const atualizarProcesso = (processoAtualizado: Processo) => {\n    setProcessos(prev => prev.map(p => \n      p.id === processoAtualizado.id ? processoAtualizado : p\n    ))\n  }\n\n  const excluirProcesso = (id: string) => {\n    setProcessos(prev => prev.filter(p => p.id !== id))\n  }\n\n  const limparProcessos = () => {\n    setProcessos([])\n    setResultadoSimulacao(null)\n  }\n\n  const gerarProcessosAleatorios = (quantidade: number) => {\n    const novosProcessos = Array.from({ length: quantidade }, (_, i) => {\n      const tipo: TipoProcesso = Math.random() > 0.5 ? \"cpu\" : \"io\"\n      return {\n        id: gerarIdUnico(),\n        nome: `${tipo.toUpperCase()}-P${i + 1}`,\n        tipo,\n        tempoChegada: Math.floor(Math.random() * 10),\n        tempoExecucaoTotal: Math.floor(Math.random() * 15) + 5,\n        bilhetes: Math.floor(Math.random() * 10) + 1,\n        cor: CORES_PROCESSOS[i % CORES_PROCESSOS.length],\n        estado: \"pronto\",\n        tempoEspera: 0,\n        tempoRetorno: 0,\n        tempoResposta: null,\n        tempoFinalizacao: null,\n        tempoRestanteCPU: 0,\n        tempoRestanteIO: 0,\n        ioBursts: [],\n        cpuBursts: [],\n        burstAtual: 0\n      } as Processo\n    }).map(p => {\n      if (p.tipo === \"io\") {\n        let tempoRestante = p.tempoExecucaoTotal\n        while (tempoRestante > 0) {\n          const cpuBurst = Math.min(Math.ceil(Math.random() * 4), tempoRestante)\n          p.cpuBursts.push(cpuBurst)\n          p.ioBursts.push(tempoIO)\n          tempoRestante -= cpuBurst\n        }\n        p.tempoRestanteCPU = p.cpuBursts[0]\n      } else {\n        p.cpuBursts = [p.tempoExecucaoTotal]\n        p.tempoRestanteCPU = p.tempoExecucaoTotal\n      }\n      return p\n    })\n\n    setProcessos(novosProcessos)\n  }\n\n  const executarSimulacao = (): ResultadoSimulacao => {\n    setSimulacaoEmExecucao(true)\n    const processosClone: Processo[] = JSON.parse(JSON.stringify(processos))\n    const linhaDoTempo: FatiaTempoExecucao[] = []\n    let tempoAtual = 0\n    let processoAtual: Processo | null = null\n    let tempoExecutando = 0\n    let processosFinalizados = 0\n\n    while (processosFinalizados < processosClone.length) {\n      processosClone.forEach(p => {\n        if (p.estado === \"esperando\") {\n          p.tempoRestanteIO--\n          if (p.tempoRestanteIO <= 0) {\n            p.estado = \"pronto\"\n            p.burstAtual++\n            if (p.burstAtual < p.cpuBursts.length) {\n              p.tempoRestanteCPU = p.cpuBursts[p.burstAtual]\n            }\n          }\n        }\n      })\n\n      const processosProntos = processosClone.filter(p => \n        p.estado === \"pronto\" && p.tempoChegada <= tempoAtual && p.tempoRestanteCPU > 0\n      )\n\n      if (!processoAtual || tempoExecutando >= quantumTempo) {\n        if (processosProntos.length > 0) {\n          const totalBilhetes = processosProntos.reduce((sum, p) => sum + p.bilhetes, 0)\n          const bilheteVencedor = Math.floor(Math.random() * totalBilhetes) + 1\n          \n          let acumulador = 0\n          for (const p of processosProntos) {\n            acumulador += p.bilhetes\n            if (acumulador >= bilheteVencedor) {\n              processoAtual = p\n              break\n            }\n          }\n\n          if (sobrecargaTrocaContexto > 0 && linhaDoTempo.length > 0) {\n            for (let i = 0; i < sobrecargaTrocaContexto; i++) {\n              linhaDoTempo.push({ tempo: tempoAtual + i, processoId: null, tipo: \"ocioso\" })\n            }\n            tempoAtual += sobrecargaTrocaContexto\n          }\n\n          tempoExecutando = 0\n          if (processoAtual.tempoResposta === null) {\n            processoAtual.tempoResposta = tempoAtual - processoAtual.tempoChegada\n          }\n        }\n      }\n\n      if (processoAtual) {\n        linhaDoTempo.push({\n          tempo: tempoAtual,\n          processoId: processoAtual.id,\n          tipo: processoAtual.tipo === \"cpu\" ? \"cpu\" : \"io\"\n        })\n\n        processoAtual.tempoRestanteCPU--\n        tempoExecutando++\n\n        if (processoAtual.tempoRestanteCPU <= 0) {\n          if (processoAtual.tipo === \"io\" && processoAtual.burstAtual < processoAtual.ioBursts.length) {\n            processoAtual.tempoRestanteIO = processoAtual.ioBursts[processoAtual.burstAtual]\n            processoAtual.estado = \"esperando\"\n          } else {\n            processoAtual.estado = \"finalizado\"\n            processoAtual.tempoFinalizacao = tempoAtual + 1\n            processoAtual.tempoRetorno = processoAtual.tempoFinalizacao - processoAtual.tempoChegada\n            processosFinalizados++\n          }\n          processoAtual = null\n        }\n      } else {\n        linhaDoTempo.push({ tempo: tempoAtual, processoId: null, tipo: \"ocioso\" })\n      }\n\n      processosProntos.forEach(p => {\n        if (p !== processoAtual) p.tempoEspera++\n      })\n\n      tempoAtual++\n    }\n\n    let tempoEsperaTotal = 0\n    let tempoRetornoTotal = 0\n    let tempoRespostaTotal = 0\n    let tempoCPUUtilizado = 0\n    let tempoIOUtilizado = 0\n\n    processosClone.forEach(p => {\n      tempoEsperaTotal += p.tempoEspera\n      tempoRetornoTotal += p.tempoRetorno\n      tempoRespostaTotal += p.tempoResposta || 0\n      \n      if (p.tipo === \"cpu\") {\n        tempoCPUUtilizado += p.tempoExecucaoTotal\n      } else {\n        tempoCPUUtilizado += p.cpuBursts.reduce((a, b) => a + b, 0)\n        tempoIOUtilizado += p.ioBursts.reduce((a, b) => a + b, 0)\n      }\n    })\n\n    const tempoTotal = linhaDoTempo.length\n    const tempoOcioso = linhaDoTempo.filter(f => f.tipo === \"ocioso\").length\n\n    const resultado: ResultadoSimulacao = {\n      linhaDoTempo,\n      processos: processosClone,\n      tempoEsperaMedia: tempoEsperaTotal / processosClone.length,\n      tempoRetornoMedio: tempoRetornoTotal / processosClone.length,\n      tempoRespostaMedio: tempoRespostaTotal / processosClone.length,\n      utilizacaoCPU: ((tempoCPUUtilizado - tempoOcioso) / tempoTotal) * 100,\n      utilizacaoIO: (tempoIOUtilizado / tempoTotal) * 100,\n      vazao: processosClone.length / tempoTotal\n    }\n\n    setResultadoSimulacao(resultado)\n    setSimulacaoEmExecucao(false)\n    return resultado\n  }\n\n  return (\n    <ContextoEscalonador.Provider value={{\n      processos,\n      adicionarProcesso,\n      atualizarProcesso,\n      excluirProcesso,\n      limparProcessos,\n      quantumTempo,\n      setQuantumTempo,\n      sobrecargaTrocaContexto,\n      setSobrecargaTrocaContexto,\n      velocidadeSimulacao,\n      setVelocidadeSimulacao,\n      resultadoSimulacao,\n      setResultadoSimulacao,\n      executarSimulacao,\n      gerarProcessosAleatorios,\n      simulacaoEmExecucao,\n      setSimulacaoEmExecucao,\n      tempoIO,\n      setTempoIO\n    }}>\n      {children}\n    </ContextoEscalonador.Provider>\n  )\n}\n\nexport const useEscalonador = () => {\n  const context = useContext(ContextoEscalonador)\n  if (!context) throw new Error(\"useEscalonador deve ser usado dentro de ProvedorEscalonador\")\n  return context\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}